<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>SPH on Keqi的博客</title><link>https://keqiye.github.io/zh-cn/tags/sph/</link><description>Recent content in SPH on Keqi的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><managingEditor>plloningye@gmail.com (Keqi Ye)</managingEditor><webMaster>plloningye@gmail.com (Keqi Ye)</webMaster><copyright>Example Person</copyright><lastBuildDate>Sun, 25 May 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://keqiye.github.io/zh-cn/tags/sph/index.xml" rel="self" type="application/rss+xml"/><item><title>SPH 核函数</title><link>https://keqiye.github.io/zh-cn/posts/sphseries/blog-post-sph2/</link><pubDate>Sun, 25 May 2025 00:00:00 +0000</pubDate><author>plloningye@gmail.com (Keqi Ye)</author><guid>https://keqiye.github.io/zh-cn/posts/sphseries/blog-post-sph2/</guid><description>&lt;p>在 SPH 方法中，**核函数（Kernel Function）**是核心组成部分之一，用于进行物理量的平滑逼近。换句话说，SPH核心功能就是将偏微分方程通过核函数近似
转换为常微分方程，随后使用时间积分解决。&lt;/p>
&lt;h1 id="数学定义与-sph-核插值">数学定义与 SPH 核插值
&lt;/h1>&lt;p>根据狄拉克函数 \( \delta \) 的定义，任意函数 \( f(\mathbf{r}) \) 可表示为：&lt;/p>
$$
f(\mathbf{r}) = \int f(\mathbf{r}') \, \delta(\mathbf{r} - \mathbf{r}') \, d\mathbf{r}'
$$
&lt;p>当 \( f(\mathbf{r}) \) 在积分区域内连续时，该表达式严格成立。&lt;/p>
&lt;hr>
&lt;h2 id="sph-中的平滑逼近">SPH 中的平滑逼近
&lt;/h2>&lt;p>在无网格方法 SPH（Smoothed Particle Hydrodynamics）中，我们用具有紧支撑的核函数 \( W(\mathbf{r} - \mathbf{r}', h) \) 替代狄拉克函数，其中 \( h \) 为平滑长度（支持半径），得到函数的平滑逼近：&lt;/p>
$$
f(\mathbf{r}) = \int f(\mathbf{r}') \, W(\mathbf{r} - \mathbf{r}', h) \, d\mathbf{r}'
$$
&lt;p>
核函数 \( W(\mathbf{r} - \mathbf{r}', h) \) 一般会具有如下特点&lt;/p>
&lt;h3 id="1-正则化条件归一性">1. 正则化条件（归一性）
&lt;/h3>&lt;p>核函数在整个空间上的积分应为 1，以保证物理量守恒：&lt;/p>
$$
\int W(\mathbf{r} - \mathbf{r}', h) \, d\mathbf{r}' = 1
$$
&lt;p>这对应于狄拉克函数的归一化性质：&lt;/p>
$$
\int \delta(\mathbf{r} - \mathbf{r}') \, d\mathbf{r}' = 1
$$
&lt;hr>
&lt;h3 id="2-收敛性delta-函数极限">2. 收敛性（Delta 函数极限）
&lt;/h3>&lt;p>当平滑长度 \( h \to 0 \) 时，核函数应趋近于狄拉克函数：&lt;/p>
$$
\lim_{h \to 0} W(\mathbf{r} - \mathbf{r}', h) = \delta(\mathbf{r} - \mathbf{r}')
$$
&lt;p>这表示核函数的逼近在理论上是收敛的，且核插值在无限分辨率下是精确的。&lt;/p>
&lt;hr>
&lt;h3 id="3-紧支性有限支持域">3. 紧支性（有限支持域）
&lt;/h3>&lt;p>核函数在距离超过某个范围 \( kh \) 后应为零：&lt;/p>
$$
W(\mathbf{r} - \mathbf{r}', h) = 0 \quad \text{当} \quad |\mathbf{r} - \mathbf{r}'| > kh
$$
&lt;p>其中常数 \( k \) 一般为 2 或 3，取决于核函数的类型。这一性质使得每个粒子的影响范围是有限的，便于高效实现邻域搜索和并行计算。&lt;/p>
&lt;hr>
&lt;p>将积分区域离散化为粒子系统，令体积元 \( d\mathbf{r}' \approx V_j = \frac{m_j}{\rho_j} \)，得：&lt;/p>
$$
f(\mathbf{r}_i) = \sum_j f(\mathbf{r}_j) \frac{m_j}{\rho_j} \, W(\mathbf{r}_i - \mathbf{r}_j, h)
$$
&lt;p>这就是 SPH 的&lt;strong>核插值公式&lt;/strong>。其本质是利用核函数在支持域内对邻近粒子的物理量进行加权平均，逼近连续场。&lt;/p>
&lt;p>对散度算子进行粒子近似可得：&lt;/p>
$$
\langle \nabla \cdot f(x_i) \rangle = -\sum_{j=1}^{N} \frac{m_j}{\rho_j} f(x_j) \cdot \nabla W_{ij}, \tag{1}
$$
&lt;p>其中核函数梯度为：&lt;/p>
$$
\nabla_i W_{ij} = \frac{x_i - x_j}{r_{ij}} \frac{\partial W_{ij}}{\partial r_{ij}} = \frac{x_{ij}}{r_{ij}} \frac{\partial W_{ij}}{\partial r_{ij}}. \tag{2}
$$
&lt;p>注意，核函数 $W_{ij} = W(\mathbf{r_i} - \mathbf{r_j}, h)$ 是关于 $\mathbf{r_j}$ 的函数，因此式(1)中多了一个负号。&lt;/p>
&lt;h2 id="常见核函数及其导数">常见核函数及其导数
&lt;/h2>&lt;p>SPH 中常用的核函数包括以下几类：&lt;/p>
&lt;h3 id="三次样条核函数-cubic-spline-kernel">三次样条核函数 (Cubic Spline Kernel)
&lt;/h3>&lt;p>核函数定义：&lt;/p>
$$
\begin{align*}
W(R,h) = \alpha_d \times
\begin{cases}
\frac{2}{3} - R^2 + \frac{1}{2}R^3, &amp; 0 \leq R &lt; 1; \\
\frac{1}{6}(2-R)^3, &amp; 1 \leq R &lt; 2; \\
0, &amp; R \geq 2.
\end{cases}
\end{align*}
$$
&lt;p>其中 $R = \frac{r}{h}$，$r$ 是粒子间距离，$h$ 是光滑长度，$\alpha_d$ 是维度归一化常数：&lt;/p>
&lt;ul>
&lt;li>一维：$\alpha_d = \frac{1}{h}$&lt;/li>
&lt;li>二维：$\alpha_d = \frac{15}{7\pi h^2}$&lt;/li>
&lt;li>三维：$\alpha_d = \frac{3}{2\pi h^3}$&lt;/li>
&lt;/ul>
&lt;p>核函数导数：&lt;/p>
$$
\frac{dW}{dR} = \alpha_d \times
\begin{cases}
-2R + \frac{3}{2}R^2, &amp; 0 \leq R &lt; 1; \\
-\frac{1}{2}(2-R)^2, &amp; 1 \leq R &lt; 2; \\
0, &amp; R \geq 2.
\end{cases}
$$</description></item><item><title>SPH 简介</title><link>https://keqiye.github.io/zh-cn/posts/sphseries/blog-post-sph1/</link><pubDate>Sun, 25 May 2025 00:00:00 +0000</pubDate><author>plloningye@gmail.com (Keqi Ye)</author><guid>https://keqiye.github.io/zh-cn/posts/sphseries/blog-post-sph1/</guid><description>&lt;p>在本系列博文中，我们将系统介绍光滑粒子流体动力学（Smoothed Particle Hydrodynamics, 简称 SPH）方法。&lt;br>
SPH 是一种无网格拉格朗日方法，广泛用于模拟连续介质如流体、固体、天体物理等问题。&lt;/p>
&lt;p>我们将从基本原理出发，逐步讲解邻域搜索、核函数、状态方程、粘性项、时间积分器等内容，并结合 CUDA 并行加速实现。&lt;/p>
&lt;p>本篇为系列导读，后续将持续更新。&lt;/p></description></item><item><title>SPH 状态方程</title><link>https://keqiye.github.io/zh-cn/posts/sphseries/blog-post-sph3/</link><pubDate>Sun, 25 May 2025 00:00:00 +0000</pubDate><author>plloningye@gmail.com (Keqi Ye)</author><guid>https://keqiye.github.io/zh-cn/posts/sphseries/blog-post-sph3/</guid><description>&lt;p>在 SPH 方法中，状态方程（Equation of State, EOS）用于将粒子的密度与压强建立联系，进而计算作用于粒子间的力。&lt;/p>
&lt;p>最常用的状态方程是 Tait 方程，其形式为：&lt;/p>
$$
P = B\left[\left(\frac{\rho}{\rho_0}\right)^\gamma - 1\right]
$$
&lt;p>其中：&lt;/p>
&lt;ul>
&lt;li>\( \rho \) 为当前密度，&lt;/li>
&lt;li>\( \rho_0 \) 为参考密度，&lt;/li>
&lt;li>\( \gamma \) 为多项式指数（通常为 7），&lt;/li>
&lt;li>\( B \) 为常数，决定压缩性。&lt;/li>
&lt;/ul>
&lt;p>合理选取 EOS 参数对于模拟结果的稳定性和准确性至关重要。&lt;/p></description></item><item><title>基于自适应步长 Runge-Kutta 方法的 SPH 计算流程</title><link>https://keqiye.github.io/zh-cn/posts/sph-adaptive-rk/</link><pubDate>Thu, 23 May 2024 10:30:00 +0800</pubDate><author>plloningye@gmail.com (Keqi Ye)</author><guid>https://keqiye.github.io/zh-cn/posts/sph-adaptive-rk/</guid><description>&lt;h2 id="1-引言">1. 引言
&lt;/h2>&lt;p>在流体动力学的数值模拟中，光滑粒子流体动力学（Smoothed Particle Hydrodynamics, SPH）是一种广泛应用的无网格拉格朗日方法。SPH方法的核心之一是对控制方程组进行时间积分，以更新每个粒子的物理状态。&lt;/p>
&lt;p>传统的时间积分方案（如简单的欧拉法或固定步长的龙格-库塔法）虽然实现简单，但在处理复杂动态过程时面临挑战：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>步长过大&lt;/strong>可能导致数值不稳定，模拟发散。&lt;/li>
&lt;li>&lt;strong>步长过小&lt;/strong>则会极大地增加计算成本，尤其是在模拟过程相对平稳的阶段。&lt;/li>
&lt;/ul>
&lt;p>为了在保证计算精度的同时提高效率，&lt;strong>自适应步长（Adaptive Time-Stepping）&lt;/strong> 的积分方法应运而生。本文将详细介绍如何将自适应步长的 Runge-Kutta (RK) 方法应用于 SPH 的计算流程中。&lt;/p>
&lt;h2 id="2-sph-核心方程">2. SPH 核心方程
&lt;/h2>&lt;p>在 SPH 中，流体被离散为一系列携带物理属性（质量、密度、速度等）的粒子。其状态演化由一组常微分方程（ODE）描述，主要包括：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>连续性方程（密度演化）&lt;/strong>:
&lt;/p>
$$
\frac{d\rho_i}{dt} = \sum_j m_j (\mathbf{v}_i - \mathbf{v}_j) \cdot \nabla_i W_{ij}
$$
&lt;/li>
&lt;li>
&lt;p>&lt;strong>动量方程（速度演化）&lt;/strong>:
&lt;/p>
$$
\frac{d\mathbf{v}_i}{dt} = -\sum_j m_j \left( \frac{p_i}{\rho_i^2} + \frac{p_j}{\rho_j^2} + \Pi_{ij} \right) \nabla_i W_{ij} + \mathbf{g}
$$
&lt;/li>
&lt;/ul>
&lt;p>其中，&lt;code>i&lt;/code> 和 &lt;code>j&lt;/code> 是粒子索引，&lt;code>m&lt;/code> 是质量，&lt;code>ρ&lt;/code> 是密度，&lt;code>p&lt;/code> 是压力，&lt;code>v&lt;/code> 是速度，&lt;code>Π&lt;/code> 是人工粘性项，&lt;code>g&lt;/code> 是外力（如重力），&lt;code>W&lt;/code> 是核函数。&lt;/p>
&lt;h2 id="3-自适应步长-runge-kutta-方法">3. 自适应步长 Runge-Kutta 方法
&lt;/h2>&lt;p>自适应步长的核心思想是：在每个积分步中，通过比较两种不同精度的计算结果来估计局部截断误差（Local Truncation Error）。根据误差的大小，动态地调整下一步的时间步长 &lt;code>Δt&lt;/code>。&lt;/p>
&lt;p>一个经典的例子是 &lt;strong>RK45&lt;/strong>（或称 Dormand-Prince、Cash-Karp 方法），它在一个步长内同时计算出一个四阶精度和一个五阶精度的解。&lt;/p>
&lt;p>&lt;strong>基本逻辑如下&lt;/strong>:&lt;/p>
&lt;ol>
&lt;li>用一个 &lt;code>Δt&lt;/code> 计算出四阶解 &lt;code>y₄&lt;/code> 和五阶解 &lt;code>y₅&lt;/code>。&lt;/li>
&lt;li>计算误差 &lt;code>ε = ||y₅ - y₄||&lt;/code>。&lt;/li>
&lt;li>将误差 &lt;code>ε&lt;/code> 与预设的容忍度 &lt;code>tol&lt;/code> 比较。
&lt;ul>
&lt;li>如果 &lt;code>ε &amp;lt;= tol&lt;/code>：接受本次计算结果（通常使用更高阶的 &lt;code>y₅&lt;/code> 作为最终结果），并可以适当增大大下一轮的步长 &lt;code>Δt&lt;/code>。&lt;/li>
&lt;li>如果 &lt;code>ε &amp;gt; tol&lt;/code>：拒绝本次计算，减小步长 &lt;code>Δt&lt;/code>，并用新的小步长重新计算当前步。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>步长调整的常用公式为：
&lt;/p>
$$
\Delta t_{\text{new}} = \Delta t_{\text{old}} \times \text{safe} \times \left( \frac{\text{tol}}{\epsilon} \right)^{p}
$$
&lt;p>
其中 &lt;code>safe&lt;/code> 是一个安全因子（如0.9），&lt;code>p&lt;/code> 是一个与方法阶数相关的指数。&lt;/p>
&lt;h2 id="4-完整的计算步骤伪代码">4. 完整的计算步骤（伪代码）
&lt;/h2>&lt;p>下面是一个结合了自适应步长 RK 方法的 SPH 主循环伪代码。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-plaintext" data-lang="plaintext">&lt;span class="line">&lt;span class="cl">// 初始化粒子位置、速度、质量等
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">InitializeParticles();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">t = 0.0;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">dt = dt_initial; // 设置一个初始步长
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">while (t &amp;lt; T_max) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 1. 邻域搜索
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 为每个粒子 i 找到其影响范围内的邻居粒子 j
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> FindNeighbors();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 2. 计算密度和压力
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 通常先根据连续性方程的右半部分计算 dρ/dt
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 然后通过状态方程（如 Tait 方程）由密度计算压力
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ComputeDensityAndPressure();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 3. 计算加速度
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 根据动量方程右半部分计算 dv/dt
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ComputeAccelerations();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 4. 执行一步自适应 RK 积分
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 这一步会尝试用当前的 dt 更新粒子状态 (位置和速度)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 如果误差过大，函数内部会减小 dt 并重试，直到成功
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 函数会返回一个被接受的、实际使用的 dt_accepted
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> dt_accepted = AdaptiveRKStep(dt);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 5. 更新时间和下一步的建议步长
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> t = t + dt_accepted;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> dt = CalculateNextOptimal_dt(dt_accepted, error_from_rk); // 根据本次误差计算下一次的建议步长
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 6. (可选) 处理边界条件
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> HandleBoundaries();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // 7. (可选) 输出数据
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> SaveData(t);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item></channel></rss>
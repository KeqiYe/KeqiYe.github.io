<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>æ ‘ç»“æ„ on Keqiçš„åšå®¢</title><link>https://keqiye.github.io/zh-cn/categories/%E6%A0%91%E7%BB%93%E6%9E%84/</link><description>Recent content in æ ‘ç»“æ„ on Keqiçš„åšå®¢</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><managingEditor>plloningye@gmail.com (Keqi Ye)</managingEditor><webMaster>plloningye@gmail.com (Keqi Ye)</webMaster><copyright>Example Person</copyright><atom:link href="https://keqiye.github.io/zh-cn/categories/%E6%A0%91%E7%BB%93%E6%9E%84/index.xml" rel="self" type="application/rss+xml"/><item><title>åŸºäºæ ‘ç»“æ„çš„ SPH ç²’å­é¢†åŸŸæœç´¢</title><link>https://keqiye.github.io/zh-cn/posts/cudatreecode/blog-post-treecode/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>plloningye@gmail.com (Keqi Ye)</author><guid>https://keqiye.github.io/zh-cn/posts/cudatreecode/blog-post-treecode/</guid><description>&lt;h1 id="æ ‘ç»“æ„åŸºäºæ ¹æ®-burtscher-å’Œ-pingali-çš„ç ”ç©¶">æ ‘ç»“æ„ï¼ˆåŸºäºæ ¹æ® Burtscher å’Œ Pingali çš„ç ”ç©¶ï¼‰
&lt;/h1>&lt;p>æœ¬æ–‡å°†ä»‹ç»å¹¿æ³›ç”¨äº SPH ä»£ç å’Œ N ä½“æ¨¡æ‹Ÿä¸­çš„æ ‘ç»“æ„ï¼ˆTree Structureï¼‰ã€‚è¿™ç§æ•°æ®ç»“æ„ä¸»è¦åº”ç”¨äºä»¥ä¸‹ä¸¤ä¸ªæ ¸å¿ƒé—®é¢˜ï¼š&lt;/p>
&lt;h3 id="1-ç²’å­é¢†åŸŸæœç´¢neighbor-search">1. ç²’å­é¢†åŸŸæœç´¢ï¼ˆNeighbor Searchï¼‰
&lt;/h3>&lt;p>åœ¨ SPHï¼ˆå…‰æ»‘ç²’å­æµä½“åŠ›å­¦ï¼‰æ¨¡æ‹Ÿä¸­ï¼Œæ¯ä¸ªç²’å­éœ€è¦åœ¨æ ¸å°ºåº¦ \( h \) èŒƒå›´å†…æŸ¥æ‰¾é‚»å±…ç²’å­ï¼Œä»¥ä¾¿è®¡ç®—å¯†åº¦ã€å‹å¼ºæ¢¯åº¦ã€ç²˜æ€§ç­‰ç‰©ç†é‡ã€‚æ ‘ç»“æ„èƒ½å¤ŸåŠ é€Ÿé‚»åŸŸæœç´¢ï¼Œå°¤å…¶é€‚ç”¨äºç²’å­åˆ†å¸ƒé«˜åº¦éå‡åŒ€çš„æƒ…å½¢ã€‚&lt;/p>
&lt;h3 id="2-è‡ªå¼•åŠ›è®¡ç®—self-gravity-computation">2. è‡ªå¼•åŠ›è®¡ç®—ï¼ˆSelf-Gravity Computationï¼‰
&lt;/h3>&lt;p>åœ¨å¼•åŠ›ä¸»å¯¼çš„ç²’å­ç³»ç»Ÿï¼ˆå¦‚æ˜Ÿç³»æ¨¡æ‹Ÿã€æ˜Ÿä½“ç¢°æ’ï¼‰ä¸­ï¼Œç²’å­é—´å­˜åœ¨ä¸‡æœ‰å¼•åŠ›ä½œç”¨ã€‚ç›´æ¥è®¡ç®—æ‰€æœ‰ç²’å­å¯¹çš„å¼•åŠ›å¼€é”€ä¸º \( \mathcal{O}(N^2) \)ï¼Œä¸å¯æ¥å—ã€‚åŸºäºæ ‘çš„è¿‘ä¼¼æ–¹æ³•ï¼ˆå¦‚ Barnes-Hut ç®—æ³•ï¼‰å¯å°†è®¡ç®—å¤æ‚åº¦é™è‡³ \( \mathcal{O}(N \log N) \)ï¼ŒåŒæ—¶ä¿æŒè¾ƒé«˜ç²¾åº¦ã€‚&lt;/p>
&lt;hr>
&lt;p>æ¥ä¸‹æ¥çš„ç« èŠ‚å°†åˆ†åˆ«ä»‹ç»æ ‘ç»“æ„åœ¨ä¸Šè¿°ä¸¤ä¸ªé—®é¢˜ä¸­çš„æ„å»ºæ–¹æ³•ã€æœç´¢ç­–ç•¥å’Œæ€§èƒ½ä¼˜åŒ–ã€‚&lt;/p>
&lt;p>å…³äºä¼ ç»Ÿçš„ &lt;strong>é“¾è¡¨æ³•ï¼ˆLinked-Listï¼‰&lt;/strong> ç²’å­é¢†åŸŸæœç´¢ï¼Œè¯·å‚è€ƒæˆ‘å¦ä¸€ç¯‡åšæ–‡ï¼š ğŸ‘‰ &lt;a class="link" href="https://keqiye.github.io/posts/SPH_neighbor_search/" >ä½¿ç”¨é“¾è¡¨è¿›è¡Œ SPH é‚»åŸŸæœç´¢&lt;/a>&lt;/p>
&lt;h1 id="å®ç°æ­¥éª¤">å®ç°æ­¥éª¤
&lt;/h1>&lt;p>æ ¹æ®ç›¸å…³æ–‡çŒ®ï¼Œæ¯æ¬¡æ‰§è¡Œè‡ªå¼•åŠ›è®¡ç®—æˆ–ç²’å­é‚»åŸŸæœç´¢æ—¶ï¼Œé€šå¸¸éœ€è¦ä»¥ä¸‹å››ä¸ªæ­¥éª¤ï¼š&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>ç¡®å®šç²’å­ç©ºé—´èŒƒå›´&lt;/strong>&lt;br>
ç»Ÿè®¡æ‰€æœ‰ç²’å­çš„ç©ºé—´è¾¹ç•Œï¼Œè·å– \( x_{\min}, x_{\max}, y_{\min}, y_{\max}, z_{\min}, z_{\max} \)ï¼Œç”¨äºåˆå§‹åŒ–æ ‘ç»“æ„çš„æ ¹èŠ‚ç‚¹æˆ–ç©ºé—´åˆ’åˆ†èŒƒå›´ã€‚&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>æ„å»ºæ ‘ç»“æ„&lt;/strong>&lt;br>
å°†ç²’å­é€’å½’åˆ’åˆ†åˆ°ç©ºé—´æ ‘èŠ‚ç‚¹ä¸­ï¼Œå¸¸ç”¨çš„æ•°æ®ç»“æ„åŒ…æ‹¬å…«å‰æ ‘ï¼ˆOctreeï¼‰æˆ– KD æ ‘ã€‚æ¯ä¸ªå¶å­èŠ‚ç‚¹åŒ…å«è‹¥å¹²ç²’å­æˆ–è¾¾åˆ°æœ€å°åˆ’åˆ†æ¡ä»¶ã€‚&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>ç²’å­ç©ºé—´æ’åº&lt;/strong>&lt;br>
å¯¹ç²’å­è¿›è¡Œ Morton ç¼–ç ï¼ˆZ-order curveï¼‰æˆ– Hilbert æ›²çº¿ç¼–ç ï¼Œå¹¶æŒ‰ç…§ç©ºé—´ä½ç½®æ’åºï¼Œä¾¿äºç¼“å­˜ä¸€è‡´æ€§å’Œåç»­å¹¶è¡Œå¤„ç†ã€‚&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>æ ‘éå†è®¡ç®—&lt;/strong>&lt;br>
éå†æ ‘ç»“æ„ï¼š&lt;/p>
&lt;ul>
&lt;li>è‹¥æ‰§è¡Œ &lt;strong>è‡ªå¼•åŠ›è®¡ç®—&lt;/strong>ï¼Œä½¿ç”¨ Barnes-Hut è¿‘ä¼¼è§„åˆ™åˆ¤æ–­æ˜¯å¦èšåˆèŠ‚ç‚¹è´¨é‡ï¼›&lt;/li>
&lt;li>è‹¥æ‰§è¡Œ &lt;strong>é‚»åŸŸæœç´¢&lt;/strong>ï¼Œåœ¨æ¯ä¸ªèŠ‚ç‚¹ä¸­åˆ¤æ–­ä¸æŸ¥è¯¢ç²’å­çš„è·ç¦»æ˜¯å¦å°äºæ ¸å°ºåº¦ \( h \)ï¼Œä»è€Œç­›é€‰å¯èƒ½é‚»å±…ã€‚&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="ç¡®å®šç²’å­ç©ºé—´èŒƒå›´">ç¡®å®šç²’å­ç©ºé—´èŒƒå›´
&lt;/h2>&lt;p>ç›´æ¥ä½¿ç”¨è§„çº¦ç®—æ³•æ±‚æœ€å¤§æœ€å°å€¼&lt;/p>
&lt;h2 id="æ„å»ºæ ‘ç»“æ„">æ„å»ºæ ‘ç»“æ„
&lt;/h2>&lt;p>ç”±äº GPU ä¸Šæ— æ³•é«˜æ•ˆå®ç°æŒ‡é’ˆå¼é“¾è¡¨ç»“æ„ï¼Œæˆ‘ä»¬ä½¿ç”¨æ•°ç»„æ¥æ¨¡æ‹Ÿæ ‘çš„é“¾æ¥å…³ç³»ï¼ˆä¾‹å¦‚å­èŠ‚ç‚¹æŒ‡é’ˆï¼‰ã€‚å‡è®¾æœ‰ä¸€ä¸ªæ•´å‹æ•°ç»„ &lt;code>child&lt;/code>ï¼Œå…¶é•¿åº¦è¿œå¤§äºç²’å­æ€»æ•° &lt;code>numParticles&lt;/code>ï¼Œå¹¶åˆå§‹åŒ–ä¸º &lt;code>-1&lt;/code>ï¼Œè¡¨ç¤ºæ‰€æœ‰èŠ‚ç‚¹å°šæœªä½¿ç”¨ã€‚&lt;/p>
&lt;h3 id="åŒºåˆ†å¶å­èŠ‚ç‚¹ä¸æ ¹èŠ‚ç‚¹">åŒºåˆ†å¶å­èŠ‚ç‚¹ä¸æ ¹èŠ‚ç‚¹
&lt;/h3>&lt;p>åœ¨æ ‘ç»“æ„ä¸­ï¼Œå¦‚ä½•åŒºåˆ†æ•´å‹æ•°ç»„ &lt;code>child&lt;/code> çš„æŸä¸€ä¸ªä½ç½®å­˜å‚¨çš„æ˜¯ &lt;strong>å¶å­èŠ‚ç‚¹ï¼ˆç²’å­ï¼‰&lt;/strong> è¿˜æ˜¯ &lt;strong>æ ¹èŠ‚ç‚¹&lt;/strong> æ˜¯ä¸€ä¸ªå…³é”®é—®é¢˜ã€‚&lt;/p>
&lt;h4 id="æ ‡è¯†æ–¹æ³•">æ ‡è¯†æ–¹æ³•ï¼š
&lt;/h4>&lt;ul>
&lt;li>&lt;strong>&lt;code>-1&lt;/code>&lt;/strong>ï¼šè¡¨ç¤ºè¯¥ä½ç½®ä¸ºç©ºï¼Œæœªè¢«å ç”¨ã€‚&lt;/li>
&lt;li>&lt;strong>&lt;code>-2&lt;/code>&lt;/strong>ï¼šè¡¨ç¤ºè¯¥ä½ç½®å·²è¢«é”å®šï¼Œå½“å‰çº¿ç¨‹æ­£åœ¨ä½¿ç”¨è¯¥ä½ç½®ï¼ˆé€šå¸¸ç”¨äºè¿›è¡ŒåŸå­æ“ä½œï¼‰ã€‚&lt;/li>
&lt;li>&lt;strong>&lt;code>0&lt;/code> åˆ° &lt;code>numParticles - 1&lt;/code>&lt;/strong>ï¼šè¡¨ç¤º &lt;strong>ç²’å­&lt;/strong>ï¼Œæ¯ä¸ªä½ç½®å¯¹åº”ä¸€ä¸ªç²’å­ã€‚&lt;/li>
&lt;li>&lt;strong>&lt;code>numParticles&lt;/code> æˆ–æ›´å¤§&lt;/strong>ï¼šè¡¨ç¤º &lt;strong>æ ¹èŠ‚ç‚¹&lt;/strong>ï¼Œç”¨äºæ ‡è¯†æ ‘ç»“æ„ä¸­çš„æ ¹èŠ‚ç‚¹ã€‚&lt;/li>
&lt;/ul>
&lt;h4 id="é”å®šä½ç½®çš„ç‰¹æ®Šè¯´æ˜">é”å®šä½ç½®çš„ç‰¹æ®Šè¯´æ˜ï¼š
&lt;/h4>&lt;p>æ ¹æ® Burtscher å’Œ Pingali çš„ç ”ç©¶ï¼Œæ ‘ç»“æ„ä¸­çš„ä½ç½®é”å®šé‡‡ç”¨å¦‚ä¸‹æ–¹å¼ï¼š&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;code>-1&lt;/code>&lt;/strong> ä»£è¡¨è¯¥ä½ç½®ä¸ºç©ºã€‚&lt;/li>
&lt;li>&lt;strong>&lt;code>-2&lt;/code>&lt;/strong> ä»£è¡¨è¯¥ä½ç½®è¢«é”å®šã€‚&lt;/li>
&lt;/ul>
&lt;p>å¦‚æœç¬¬ &lt;code>i&lt;/code> ä¸ªä½ç½®è¢«é”å®šï¼Œé‚£ä¹ˆï¼š&lt;/p>
&lt;ul>
&lt;li>åœ¨ &lt;strong>ä¸‰ç»´&lt;/strong> æƒ…å†µä¸‹ï¼Œ&lt;code>8*i+0&lt;/code> åˆ° &lt;code>7&lt;/code>ï¼ˆå³ä¸€ä¸ªå…«å²”æ ‘åŠå…¶å­æ ‘ç­‰ï¼‰éƒ½è¢«é”å®šï¼›&lt;/li>
&lt;li>åœ¨ &lt;strong>äºŒç»´&lt;/strong> æƒ…å†µä¸‹ï¼Œ&lt;code>4*i+0&lt;/code> åˆ° &lt;code>3&lt;/code>ï¼ˆå³ä¸€ä¸ªå››å²”æ ‘åŠå…¶å­æ ‘ç­‰ï¼‰éƒ½è¢«é”å®šï¼›&lt;/li>
&lt;li>åœ¨ &lt;strong>ä¸€ç»´&lt;/strong> æƒ…å†µä¸‹ï¼Œ&lt;code>i&lt;/code> åŠå…¶ç›¸é‚»éƒ¨åˆ†ä¹Ÿä¼šè¢«é”å®šã€‚&lt;/li>
&lt;/ul>
&lt;p>è¿™æ„å‘³ç€ï¼Œå¦‚æœä¸€ä¸ªä½ç½®è¢«é”å®šï¼Œ&lt;strong>å…¶ä»–çº¿ç¨‹å°†æ— æ³•è®¿é—®è¯¥ä½ç½®çš„å­æ ‘æˆ–å…¶å­æ ‘çš„å­æ ‘&lt;/strong>ï¼Œç¡®ä¿äº†å¹¶è¡Œè®¡ç®—ä¸­èŠ‚ç‚¹åŠå…¶ç›¸å…³å­èŠ‚ç‚¹çš„å®‰å…¨ã€‚&lt;/p>
&lt;h3 id="ä½¿ç”¨åŸå­æ“ä½œåŒæ­¥çº¿ç¨‹">ä½¿ç”¨åŸå­æ“ä½œåŒæ­¥çº¿ç¨‹
&lt;/h3>&lt;p>å½“å¤šä¸ªçº¿ç¨‹å¹¶å‘åœ°å°è¯•è®¿é—®åŒä¸€ä¸ªå­èŠ‚ç‚¹æ§½ä½æ—¶ï¼Œå¯ä»¥ä½¿ç”¨ CUDA æä¾›çš„åŸå­æ“ä½œ &lt;code>atomicCAS&lt;/code>ï¼ˆCompare And Swapï¼‰æ¥è¿›è¡Œçº¿ç¨‹é—´åŒæ­¥ã€‚&lt;/p>
&lt;p>ä»¥ä¸‹æ˜¯åŸå­æ“ä½œçš„ä»£ç ç¤ºä¾‹ï¼š&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">int re = atomicCAS(&amp;amp;child[p], -1, -2); // å°è¯•å ç”¨ child[p]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>è¯¥æ“ä½œçš„å«ä¹‰æ˜¯ï¼š&lt;/p>
&lt;ul>
&lt;li>&lt;strong>è‹¥ &lt;code>child[p] == -1&lt;/code>&lt;/strong>ï¼šè¡¨ç¤ºè¯¥æ§½ä½å°šæœªè¢«å ç”¨ï¼Œå½“å‰çº¿ç¨‹æˆåŠŸå°†å…¶åŸå­åœ°è®¾ç½®ä¸º &lt;code>-2&lt;/code>ï¼Œè¡¨ç¤ºâ€œé”å®šä¸­â€æˆ–â€œå‡†å¤‡æ’å…¥â€ï¼›&lt;/li>
&lt;li>&lt;strong>è‹¥ &lt;code>child[p] != -1&lt;/code>&lt;/strong>ï¼šè¯´æ˜è¯¥æ§½ä½å·²è¢«å…¶ä»–çº¿ç¨‹å ç”¨æˆ–å·²è¢«æ’å…¥ï¼Œå½“å‰çº¿ç¨‹éœ€é€€å‡ºæˆ–é‡è¯•ï¼›&lt;/li>
&lt;li>&lt;strong>è¿”å›å€¼ &lt;code>re&lt;/code>&lt;/strong>ï¼šè¡¨ç¤ºæ“ä½œå‰çš„æ—§å€¼ã€‚å¦‚æœ &lt;code>re == -1&lt;/code>ï¼Œåˆ™è¯´æ˜å½“å‰çº¿ç¨‹æˆåŠŸé”å®šäº†è¯¥èŠ‚ç‚¹ã€‚å¦‚æœ &lt;code>re != -1&lt;/code> ï¼Œåˆ™ &lt;code>atomicCAS&lt;/code> å‡½æ•°å‘ç°æ¯”è¾ƒä¸æˆç«‹ï¼Œç›´æ¥è¿”å›äº†æ—§å€¼ï¼Œä¹Ÿä¸ä¼šæ›¿æ¢&lt;code>-2&lt;/code>è€Œæ‰“ä¹±&lt;code>child&lt;/code>æ•°ç»„å†…å®¹ã€‚&lt;/li>
&lt;/ul>
&lt;p>å†™åˆ°è¿™é‡Œï¼Œæ ‘ç»“æ„æ•°ç»„&lt;code>child&lt;/code>çš„æ„å»ºå°±å¾ˆå®¹æ˜“äº†ã€‚ä¸‹é¢æ˜¯ä»£ç &lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt"> 10
&lt;/span>&lt;span class="lnt"> 11
&lt;/span>&lt;span class="lnt"> 12
&lt;/span>&lt;span class="lnt"> 13
&lt;/span>&lt;span class="lnt"> 14
&lt;/span>&lt;span class="lnt"> 15
&lt;/span>&lt;span class="lnt"> 16
&lt;/span>&lt;span class="lnt"> 17
&lt;/span>&lt;span class="lnt"> 18
&lt;/span>&lt;span class="lnt"> 19
&lt;/span>&lt;span class="lnt"> 20
&lt;/span>&lt;span class="lnt"> 21
&lt;/span>&lt;span class="lnt"> 22
&lt;/span>&lt;span class="lnt"> 23
&lt;/span>&lt;span class="lnt"> 24
&lt;/span>&lt;span class="lnt"> 25
&lt;/span>&lt;span class="lnt"> 26
&lt;/span>&lt;span class="lnt"> 27
&lt;/span>&lt;span class="lnt"> 28
&lt;/span>&lt;span class="lnt"> 29
&lt;/span>&lt;span class="lnt"> 30
&lt;/span>&lt;span class="lnt"> 31
&lt;/span>&lt;span class="lnt"> 32
&lt;/span>&lt;span class="lnt"> 33
&lt;/span>&lt;span class="lnt"> 34
&lt;/span>&lt;span class="lnt"> 35
&lt;/span>&lt;span class="lnt"> 36
&lt;/span>&lt;span class="lnt"> 37
&lt;/span>&lt;span class="lnt"> 38
&lt;/span>&lt;span class="lnt"> 39
&lt;/span>&lt;span class="lnt"> 40
&lt;/span>&lt;span class="lnt"> 41
&lt;/span>&lt;span class="lnt"> 42
&lt;/span>&lt;span class="lnt"> 43
&lt;/span>&lt;span class="lnt"> 44
&lt;/span>&lt;span class="lnt"> 45
&lt;/span>&lt;span class="lnt"> 46
&lt;/span>&lt;span class="lnt"> 47
&lt;/span>&lt;span class="lnt"> 48
&lt;/span>&lt;span class="lnt"> 49
&lt;/span>&lt;span class="lnt"> 50
&lt;/span>&lt;span class="lnt"> 51
&lt;/span>&lt;span class="lnt"> 52
&lt;/span>&lt;span class="lnt"> 53
&lt;/span>&lt;span class="lnt"> 54
&lt;/span>&lt;span class="lnt"> 55
&lt;/span>&lt;span class="lnt"> 56
&lt;/span>&lt;span class="lnt"> 57
&lt;/span>&lt;span class="lnt"> 58
&lt;/span>&lt;span class="lnt"> 59
&lt;/span>&lt;span class="lnt"> 60
&lt;/span>&lt;span class="lnt"> 61
&lt;/span>&lt;span class="lnt"> 62
&lt;/span>&lt;span class="lnt"> 63
&lt;/span>&lt;span class="lnt"> 64
&lt;/span>&lt;span class="lnt"> 65
&lt;/span>&lt;span class="lnt"> 66
&lt;/span>&lt;span class="lnt"> 67
&lt;/span>&lt;span class="lnt"> 68
&lt;/span>&lt;span class="lnt"> 69
&lt;/span>&lt;span class="lnt"> 70
&lt;/span>&lt;span class="lnt"> 71
&lt;/span>&lt;span class="lnt"> 72
&lt;/span>&lt;span class="lnt"> 73
&lt;/span>&lt;span class="lnt"> 74
&lt;/span>&lt;span class="lnt"> 75
&lt;/span>&lt;span class="lnt"> 76
&lt;/span>&lt;span class="lnt"> 77
&lt;/span>&lt;span class="lnt"> 78
&lt;/span>&lt;span class="lnt"> 79
&lt;/span>&lt;span class="lnt"> 80
&lt;/span>&lt;span class="lnt"> 81
&lt;/span>&lt;span class="lnt"> 82
&lt;/span>&lt;span class="lnt"> 83
&lt;/span>&lt;span class="lnt"> 84
&lt;/span>&lt;span class="lnt"> 85
&lt;/span>&lt;span class="lnt"> 86
&lt;/span>&lt;span class="lnt"> 87
&lt;/span>&lt;span class="lnt"> 88
&lt;/span>&lt;span class="lnt"> 89
&lt;/span>&lt;span class="lnt"> 90
&lt;/span>&lt;span class="lnt"> 91
&lt;/span>&lt;span class="lnt"> 92
&lt;/span>&lt;span class="lnt"> 93
&lt;/span>&lt;span class="lnt"> 94
&lt;/span>&lt;span class="lnt"> 95
&lt;/span>&lt;span class="lnt"> 96
&lt;/span>&lt;span class="lnt"> 97
&lt;/span>&lt;span class="lnt"> 98
&lt;/span>&lt;span class="lnt"> 99
&lt;/span>&lt;span class="lnt">100
&lt;/span>&lt;span class="lnt">101
&lt;/span>&lt;span class="lnt">102
&lt;/span>&lt;span class="lnt">103
&lt;/span>&lt;span class="lnt">104
&lt;/span>&lt;span class="lnt">105
&lt;/span>&lt;span class="lnt">106
&lt;/span>&lt;span class="lnt">107
&lt;/span>&lt;span class="lnt">108
&lt;/span>&lt;span class="lnt">109
&lt;/span>&lt;span class="lnt">110
&lt;/span>&lt;span class="lnt">111
&lt;/span>&lt;span class="lnt">112
&lt;/span>&lt;span class="lnt">113
&lt;/span>&lt;span class="lnt">114
&lt;/span>&lt;span class="lnt">115
&lt;/span>&lt;span class="lnt">116
&lt;/span>&lt;span class="lnt">117
&lt;/span>&lt;span class="lnt">118
&lt;/span>&lt;span class="lnt">119
&lt;/span>&lt;span class="lnt">120
&lt;/span>&lt;span class="lnt">121
&lt;/span>&lt;span class="lnt">122
&lt;/span>&lt;span class="lnt">123
&lt;/span>&lt;span class="lnt">124
&lt;/span>&lt;span class="lnt">125
&lt;/span>&lt;span class="lnt">126
&lt;/span>&lt;span class="lnt">127
&lt;/span>&lt;span class="lnt">128
&lt;/span>&lt;span class="lnt">129
&lt;/span>&lt;span class="lnt">130
&lt;/span>&lt;span class="lnt">131
&lt;/span>&lt;span class="lnt">132
&lt;/span>&lt;span class="lnt">133
&lt;/span>&lt;span class="lnt">134
&lt;/span>&lt;span class="lnt">135
&lt;/span>&lt;span class="lnt">136
&lt;/span>&lt;span class="lnt">137
&lt;/span>&lt;span class="lnt">138
&lt;/span>&lt;span class="lnt">139
&lt;/span>&lt;span class="lnt">140
&lt;/span>&lt;span class="lnt">141
&lt;/span>&lt;span class="lnt">142
&lt;/span>&lt;span class="lnt">143
&lt;/span>&lt;span class="lnt">144
&lt;/span>&lt;span class="lnt">145
&lt;/span>&lt;span class="lnt">146
&lt;/span>&lt;span class="lnt">147
&lt;/span>&lt;span class="lnt">148
&lt;/span>&lt;span class="lnt">149
&lt;/span>&lt;span class="lnt">150
&lt;/span>&lt;span class="lnt">151
&lt;/span>&lt;span class="lnt">152
&lt;/span>&lt;span class="lnt">153
&lt;/span>&lt;span class="lnt">154
&lt;/span>&lt;span class="lnt">155
&lt;/span>&lt;span class="lnt">156
&lt;/span>&lt;span class="lnt">157
&lt;/span>&lt;span class="lnt">158
&lt;/span>&lt;span class="lnt">159
&lt;/span>&lt;span class="lnt">160
&lt;/span>&lt;span class="lnt">161
&lt;/span>&lt;span class="lnt">162
&lt;/span>&lt;span class="lnt">163
&lt;/span>&lt;span class="lnt">164
&lt;/span>&lt;span class="lnt">165
&lt;/span>&lt;span class="lnt">166
&lt;/span>&lt;span class="lnt">167
&lt;/span>&lt;span class="lnt">168
&lt;/span>&lt;span class="lnt">169
&lt;/span>&lt;span class="lnt">170
&lt;/span>&lt;span class="lnt">171
&lt;/span>&lt;span class="lnt">172
&lt;/span>&lt;span class="lnt">173
&lt;/span>&lt;span class="lnt">174
&lt;/span>&lt;span class="lnt">175
&lt;/span>&lt;span class="lnt">176
&lt;/span>&lt;span class="lnt">177
&lt;/span>&lt;span class="lnt">178
&lt;/span>&lt;span class="lnt">179
&lt;/span>&lt;span class="lnt">180
&lt;/span>&lt;span class="lnt">181
&lt;/span>&lt;span class="lnt">182
&lt;/span>&lt;span class="lnt">183
&lt;/span>&lt;span class="lnt">184
&lt;/span>&lt;span class="lnt">185
&lt;/span>&lt;span class="lnt">186
&lt;/span>&lt;span class="lnt">187
&lt;/span>&lt;span class="lnt">188
&lt;/span>&lt;span class="lnt">189
&lt;/span>&lt;span class="lnt">190
&lt;/span>&lt;span class="lnt">191
&lt;/span>&lt;span class="lnt">192
&lt;/span>&lt;span class="lnt">193
&lt;/span>&lt;span class="lnt">194
&lt;/span>&lt;span class="lnt">195
&lt;/span>&lt;span class="lnt">196
&lt;/span>&lt;span class="lnt">197
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">__global__ void buildTree()
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">{
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> register int inc = blockDim.x * gridDim.x;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> register int i = threadIdx.x + blockIdx.x * blockDim.x;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> register int k;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> register int childIndex, child;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> register int lockedIndex;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> register double x;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#if DIM &amp;gt; 1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> register double y;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#endif
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> register double r;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> register double dx;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#if DIM &amp;gt; 1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> register double dy;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#endif
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> register double rootRadius = radius;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> register double rootX = p.x[numNodes-1];
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#if DIM &amp;gt; 1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> register double rootY = p.y[numNodes-1];
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#endif
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> register int depth = 0;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> register int isNewParticle = TRUE;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> register int currentNodeIndex;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> register int newNodeIndex;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> register int subtreeNodeIndex;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#if DIM == 3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> register double z;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> register double dz;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> register double rootZ = p.z[numNodes-1];
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#endif
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> volatile double *px, *pm;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#if DIM &amp;gt; 1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> volatile double *py;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#if DIM == 3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> volatile double *pz;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#endif
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#endif
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> px = p.x;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> pm = p.m;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#if DIM &amp;gt; 1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> py = p.y;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#if DIM == 3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> pz = p.z;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#endif
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#endif
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> while (i &amp;lt; numParticles) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> depth = 0;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if (isNewParticle) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> isNewParticle = FALSE;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // cache particle data
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> x = px[i];
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> p.ax[i] = 0.0;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#if DIM &amp;gt; 1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> y = py[i];
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> p.ay[i] = 0.0;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#if DIM == 3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> z = pz[i];
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> p.az[i] = 0.0;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#endif
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#endif
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // start at root
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> currentNodeIndex = numNodes-1;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> r = rootRadius;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> childIndex = 0;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if (x &amp;gt; rootX) childIndex = 1;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#if DIM &amp;gt; 1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if (y &amp;gt; rootY) childIndex += 2;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#if DIM == 3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if (z &amp;gt; rootZ) childIndex += 4;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#endif
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#endif
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // follow path to leaf
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> child = childList[childListIndex(currentNodeIndex, childIndex)];
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> /* leaves are 0 ... numParticles */
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> while (child &amp;gt;= numParticles) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> currentNodeIndex = child;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> depth++;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> r *= 0.5;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // which child?
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> childIndex = 0;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if (x &amp;gt; px[currentNodeIndex]) childIndex = 1;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#if DIM &amp;gt; 1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if (y &amp;gt; py[currentNodeIndex]) childIndex += 2;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#if DIM &amp;gt; 2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if (z &amp;gt; pz[currentNodeIndex]) childIndex += 4;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#endif
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#endif
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> child = childList[childListIndex(currentNodeIndex, childIndex)];
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // we want to insert the current particle i into currentNodeIndex&amp;#39;s child at position childIndex
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // where child is now empty, locked or a particle
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // if empty -&amp;gt; simply insert, if particle -&amp;gt; create new subtree
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if (child != LOCKED) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // the position where we want to place the particle gets locked
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> lockedIndex = childListIndex(currentNodeIndex, childIndex);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // atomic compare and save: compare if child is still the current value of childlist at the index lockedIndex, if so, lock it
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // atomicCAS returns the old value of child
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if (child == atomicCAS((int *) &amp;amp;childList[lockedIndex], child, LOCKED)) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // if the destination is empty, insert particle
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if (child == EMPTY) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // insert the particle into this leaf
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> childList[lockedIndex] = i;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> } else {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // there is already a particle, create new inner node
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> subtreeNodeIndex = -1;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> do {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // get the next free nodeIndex
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> newNodeIndex = atomicSub((int * ) &amp;amp;maxNodeIndex, 1) - 1;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // throw error if there aren&amp;#39;t enough node indices available
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if (newNodeIndex &amp;lt;= numParticles) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> printf(&amp;#34;(thread %d): error during tree creation: not enough nodes. newNodeIndex %d, maxNodeIndex %d, numParticles: %d\n&amp;#34;, threadIdx.x, newNodeIndex, maxNodeIndex, numParticles);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> assert(0);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // the first available free nodeIndex will be the subtree node
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> subtreeNodeIndex = max(subtreeNodeIndex, newNodeIndex);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> dx = (childIndex &amp;amp; 1) * r;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#if DIM &amp;gt; 1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> dy = ((childIndex &amp;gt;&amp;gt; 1) &amp;amp; 1) * r;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#if DIM == 3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> dz = ((childIndex &amp;gt;&amp;gt; 2) &amp;amp; 1) * r;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#endif
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#endif
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> depth++;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> r *= 0.5;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // we save the radius here, so we can use it during neighboursearch. we have to set it to EMPTY after the neighboursearch
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> pm[newNodeIndex] = r;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> dx = px[newNodeIndex] = px[currentNodeIndex] - r + dx;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#if DIM &amp;gt; 1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> dy = py[newNodeIndex] = py[currentNodeIndex] - r + dy;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#if DIM == 3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> dz = pz[newNodeIndex] = pz[currentNodeIndex] - r + dz;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#endif
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#endif
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> for (k = 0; k &amp;lt; numChildren; k++) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> childList[childListIndex(newNodeIndex, k)] = EMPTY;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if (subtreeNodeIndex != newNodeIndex) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // this condition is true when the two particles are so close to each other, that they are
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // again put into the same node, so we have to create another new inner node.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // in this case, currentNodeIndex is the previous newNodeIndex
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // and childIndex is the place where the particle i belongs to, relative to the previous newNodeIndex
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> childList[childListIndex(currentNodeIndex, childIndex)] = newNodeIndex;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> childIndex = 0;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if (px[child] &amp;gt; dx) childIndex = 1;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#if DIM &amp;gt; 1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if (py[child] &amp;gt; dy) childIndex += 2;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#if DIM == 3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if (pz[child] &amp;gt; dz) childIndex += 4;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#endif
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#endif
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> childList[childListIndex(newNodeIndex, childIndex)] = child;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // compare positions of particle i to the new node
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> currentNodeIndex = newNodeIndex;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> childIndex = 0;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if (x &amp;gt; dx) childIndex = 1;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#if DIM &amp;gt; 1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if (y &amp;gt; dy) childIndex += 2;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#if DIM == 3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if (z &amp;gt; dz) childIndex += 4;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#endif
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#endif
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> child = childList[childListIndex(currentNodeIndex, childIndex)];
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // continue creating new nodes (with half radius each) until the other particle is not in the same spot in the tree
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> } while (child &amp;gt;= 0);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> childList[childListIndex(currentNodeIndex, childIndex)] = i;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> __threadfence();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> //__threadfence() is used to halt the current thread until all previous writes to shared and global memory are visible
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // by other threads. It does not halt nor affect the position of other threads though!
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> childList[lockedIndex] = subtreeNodeIndex;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> p.depth[i] = depth;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> // continue with next particle
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> i += inc;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> isNewParticle = TRUE;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> __syncthreads(); // child was locked, wait for other threads to unlock
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>// æ ¸å‡½æ•°ï¼šæ„å»ºå…«å‰æ ‘ï¼ˆæˆ–å››å‰æ ‘/äºŒå‰æ ‘ï¼Œå–å†³äº DIMï¼‰ç”¨äºç²’å­é‚»åŸŸæœç´¢æˆ–è‡ªå¼•åŠ›è®¡ç®—
// è¾“å…¥ï¼š
// p - ç²’å­æ•°æ®ç»“æ„ï¼ŒåŒ…æ‹¬ä½ç½® px, py, pz å’Œè´¨é‡ pmï¼Œä»¥åŠåŠ é€Ÿåº¦ ax, ay, az
// numParticles - ç²’å­æ€»æ•°
// numNodes - æ€»èŠ‚ç‚¹æ•°ï¼ˆåŒ…æ‹¬ç²’å­å’Œå†…éƒ¨èŠ‚ç‚¹ï¼‰
// radius - æ ¹èŠ‚ç‚¹å¤§å°
// è¾“å‡ºï¼š
// childList - æ ‘ç»“æ„ä¸­æ¯ä¸ªèŠ‚ç‚¹çš„å­èŠ‚ç‚¹æ•°ç»„
// maxNodeIndex - åŸå­é€’å‡çš„å…¨å±€å˜é‡ï¼Œç”¨äºåˆ†é…æ–°å†…éƒ¨èŠ‚ç‚¹ç´¢å¼•&lt;/p>
&lt;p>&lt;strong>global&lt;/strong> void buildTree(ParticleData p, int* childList, int numParticles, int numNodes, double radius, int* maxNodeIndex)
{
int inc = blockDim.x * gridDim.x;
int i = threadIdx.x + blockIdx.x * blockDim.x;&lt;/p>
&lt;pre>&lt;code>while (i &amp;lt; numParticles) {
double x = p.x[i], y = 0.0, z = 0.0;
&lt;/code>&lt;/pre>
&lt;p>#if DIM &amp;gt; 1
y = p.y[i];
#if DIM == 3
z = p.z[i];
#endif
#endif
double ax = 0.0, ay = 0.0, az = 0.0;
p.ax[i] = ax;
#if DIM &amp;gt; 1
p.ay[i] = ay;
#if DIM == 3
p.az[i] = az;
#endif
#endif&lt;/p>
&lt;pre>&lt;code> // ä»æ ¹èŠ‚ç‚¹å¼€å§‹
int currentNodeIndex = numNodes - 1;
double rootX = p.x[currentNodeIndex];
double rootY = 0.0, rootZ = 0.0;
&lt;/code>&lt;/pre>
&lt;p>#if DIM &amp;gt; 1
rootY = p.y[currentNodeIndex];
#if DIM == 3
rootZ = p.z[currentNodeIndex];
#endif
#endif
double r = radius;
int depth = 0;&lt;/p>
&lt;pre>&lt;code> // ç¡®å®šåˆå§‹çš„å­èŠ‚ç‚¹ç´¢å¼•
int childIndex = 0;
if (x &amp;gt; rootX) childIndex |= 1;
&lt;/code>&lt;/pre>
&lt;p>#if DIM &amp;gt; 1
if (y &amp;gt; rootY) childIndex |= 2;
#if DIM == 3
if (z &amp;gt; rootZ) childIndex |= 4;
#endif
#endif&lt;/p>
&lt;pre>&lt;code> // éå†æ ‘ç›´åˆ°é‡åˆ°å¶å­èŠ‚ç‚¹æˆ–ç©ºä½
int child = childList[childListIndex(currentNodeIndex, childIndex)];
while (child &amp;gt;= numParticles) {
currentNodeIndex = child;
depth++;
r *= 0.5;
// å†æ¬¡ç¡®å®šå­èŠ‚ç‚¹ç´¢å¼•
childIndex = 0;
if (x &amp;gt; p.x[currentNodeIndex]) childIndex |= 1;
&lt;/code>&lt;/pre>
&lt;p>#if DIM &amp;gt; 1
if (y &amp;gt; p.y[currentNodeIndex]) childIndex |= 2;
#if DIM == 3
if (z &amp;gt; p.z[currentNodeIndex]) childIndex |= 4;
#endif
#endif
child = childList[childListIndex(currentNodeIndex, childIndex)];
}&lt;/p>
&lt;pre>&lt;code> // å°è¯•é”å®šå­èŠ‚ç‚¹æ§½ä½
int lockedIndex = childListIndex(currentNodeIndex, childIndex);
if (child != LOCKED &amp;amp;&amp;amp; child == atomicCAS(&amp;amp;childList[lockedIndex], child, LOCKED)) {
if (child == EMPTY) {
childList[lockedIndex] = i;
} else {
// åˆ›å»ºæ–°å­æ ‘
int subtreeNodeIndex = -1;
do {
int newNodeIndex = atomicSub(maxNodeIndex, 1) - 1;
if (newNodeIndex &amp;lt;= numParticles) {
printf(&amp;quot;ERROR: Not enough nodes. newNodeIndex = %d\n&amp;quot;, newNodeIndex);
return;
}
subtreeNodeIndex = max(subtreeNodeIndex, newNodeIndex);
double dx = (childIndex &amp;amp; 1) * r;
double dy = 0.0, dz = 0.0;
&lt;/code>&lt;/pre>
&lt;p>#if DIM &amp;gt; 1
dy = ((childIndex &amp;raquo; 1) &amp;amp; 1) * r;
#if DIM == 3
dz = ((childIndex &amp;raquo; 2) &amp;amp; 1) * r;
#endif
#endif
r *= 0.5;
p.m[newNodeIndex] = r;
p.x[newNodeIndex] = p.x[currentNodeIndex] - r + dx;
#if DIM &amp;gt; 1
p.y[newNodeIndex] = p.y[currentNodeIndex] - r + dy;
#if DIM == 3
p.z[newNodeIndex] = p.z[currentNodeIndex] - r + dz;
#endif
#endif&lt;/p>
&lt;pre>&lt;code> for (int k = 0; k &amp;lt; numChildren; ++k)
childList[childListIndex(newNodeIndex, k)] = EMPTY;
if (subtreeNodeIndex != newNodeIndex)
childList[childListIndex(currentNodeIndex, childIndex)] = newNodeIndex;
// å†æ¬¡å¯»æ‰¾å½“å‰ç²’å­ä¸å·²æœ‰ç²’å­åº”å¤„ä½ç½®
childIndex = 0;
if (p.x[child] &amp;gt; p.x[newNodeIndex]) childIndex |= 1;
&lt;/code>&lt;/pre>
&lt;p>#if DIM &amp;gt; 1
if (p.y[child] &amp;gt; p.y[newNodeIndex]) childIndex |= 2;
#if DIM == 3
if (p.z[child] &amp;gt; p.z[newNodeIndex]) childIndex |= 4;
#endif
#endif
childList[childListIndex(newNodeIndex, childIndex)] = child;&lt;/p>
&lt;pre>&lt;code> currentNodeIndex = newNodeIndex;
childIndex = 0;
if (x &amp;gt; p.x[currentNodeIndex]) childIndex |= 1;
&lt;/code>&lt;/pre>
&lt;p>#if DIM &amp;gt; 1
if (y &amp;gt; p.y[currentNodeIndex]) childIndex |= 2;
#if DIM == 3
if (z &amp;gt; p.z[currentNodeIndex]) childIndex |= 4;
#endif
#endif
child = childList[childListIndex(currentNodeIndex, childIndex)];
} while (child &amp;gt;= 0);&lt;/p>
&lt;pre>&lt;code> childList[childListIndex(currentNodeIndex, childIndex)] = i;
__threadfence();
childList[lockedIndex] = subtreeNodeIndex;
}
p.depth[i] = depth;
i += inc;
}
__syncthreads(); // ç­‰å¾…é”é‡Šæ”¾
}
&lt;/code>&lt;/pre>
&lt;p>}&lt;/p>
&lt;p>[1] Burtscher, Martin, and Keshav Pingali. &amp;ldquo;An efficient CUDA implementation of the tree-based barnes hut n-body algorithm.&amp;rdquo; &lt;em>GPU computing Gems Emerald edition&lt;/em>. Morgan Kaufmann, 2011. 75-92.&lt;/p></description></item></channel></rss>
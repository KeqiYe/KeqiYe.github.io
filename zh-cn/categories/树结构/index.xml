<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>树结构 on Keqi的博客</title><link>https://keqiye.github.io/zh-cn/categories/%E6%A0%91%E7%BB%93%E6%9E%84/</link><description>Recent content in 树结构 on Keqi的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><managingEditor>plloningye@gmail.com (Keqi Ye)</managingEditor><webMaster>plloningye@gmail.com (Keqi Ye)</webMaster><copyright>Example Person</copyright><atom:link href="https://keqiye.github.io/zh-cn/categories/%E6%A0%91%E7%BB%93%E6%9E%84/index.xml" rel="self" type="application/rss+xml"/><item><title>基于树结构的 SPH 粒子领域搜索</title><link>https://keqiye.github.io/zh-cn/posts/cudatreecode/blog-post-treecode/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>plloningye@gmail.com (Keqi Ye)</author><guid>https://keqiye.github.io/zh-cn/posts/cudatreecode/blog-post-treecode/</guid><description>&lt;h1 id="树结构基于根据-burtscher-和-pingali-的研究">树结构（基于根据 Burtscher 和 Pingali 的研究）
&lt;/h1>&lt;p>本文将介绍广泛用于 SPH 代码和 N 体模拟中的树结构（Tree Structure）。这种数据结构主要应用于以下两个核心问题：&lt;/p>
&lt;h3 id="1-粒子领域搜索neighbor-search">1. 粒子领域搜索（Neighbor Search）
&lt;/h3>&lt;p>在 SPH（光滑粒子流体力学）模拟中，每个粒子需要在核尺度 \( h \) 范围内查找邻居粒子，以便计算密度、压强梯度、粘性等物理量。树结构能够加速邻域搜索，尤其适用于粒子分布高度非均匀的情形。&lt;/p>
&lt;h3 id="2-自引力计算self-gravity-computation">2. 自引力计算（Self-Gravity Computation）
&lt;/h3>&lt;p>在引力主导的粒子系统（如星系模拟、星体碰撞）中，粒子间存在万有引力作用。直接计算所有粒子对的引力开销为 \( \mathcal{O}(N^2) \)，不可接受。基于树的近似方法（如 Barnes-Hut 算法）可将计算复杂度降至 \( \mathcal{O}(N \log N) \)，同时保持较高精度。&lt;/p>
&lt;hr>
&lt;p>接下来的章节将分别介绍树结构在上述两个问题中的构建方法、搜索策略和性能优化。&lt;/p>
&lt;p>关于传统的 &lt;strong>链表法（Linked-List）&lt;/strong> 粒子领域搜索，请参考我另一篇博文： 👉 &lt;a class="link" href="https://keqiye.github.io/posts/SPH_neighbor_search/" >使用链表进行 SPH 邻域搜索&lt;/a>&lt;/p>
&lt;h1 id="实现步骤">实现步骤
&lt;/h1>&lt;p>根据相关文献，每次执行自引力计算或粒子邻域搜索时，通常需要以下四个步骤：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>确定粒子空间范围&lt;/strong>&lt;br>
统计所有粒子的空间边界，获取 \( x_{\min}, x_{\max}, y_{\min}, y_{\max}, z_{\min}, z_{\max} \)，用于初始化树结构的根节点或空间划分范围。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>构建树结构&lt;/strong>&lt;br>
将粒子递归划分到空间树节点中，常用的数据结构包括八叉树（Octree）或 KD 树。每个叶子节点包含若干粒子或达到最小划分条件。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>粒子空间排序&lt;/strong>&lt;br>
对粒子进行 Morton 编码（Z-order curve）或 Hilbert 曲线编码，并按照空间位置排序，便于缓存一致性和后续并行处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>树遍历计算&lt;/strong>&lt;br>
遍历树结构：&lt;/p>
&lt;ul>
&lt;li>若执行 &lt;strong>自引力计算&lt;/strong>，使用 Barnes-Hut 近似规则判断是否聚合节点质量；&lt;/li>
&lt;li>若执行 &lt;strong>邻域搜索&lt;/strong>，在每个节点中判断与查询粒子的距离是否小于核尺度 \( h \)，从而筛选可能邻居。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="确定粒子空间范围">确定粒子空间范围
&lt;/h2>&lt;p>直接使用规约算法求最大最小值&lt;/p>
&lt;h2 id="构建树结构">构建树结构
&lt;/h2>&lt;p>由于 GPU 上无法高效实现指针式链表结构，我们使用数组来模拟树的链接关系（例如子节点指针）。假设有一个整型数组 &lt;code>child&lt;/code>，其长度远大于粒子总数 &lt;code>numParticles&lt;/code>，并初始化为 &lt;code>-1&lt;/code>，表示所有节点尚未使用。&lt;/p>
&lt;h3 id="区分叶子节点与根节点">区分叶子节点与根节点
&lt;/h3>&lt;p>在树结构中，如何区分整型数组 &lt;code>child&lt;/code> 的某一个位置存储的是 &lt;strong>叶子节点（粒子）&lt;/strong> 还是 &lt;strong>根节点&lt;/strong> 是一个关键问题。&lt;/p>
&lt;h4 id="标识方法">标识方法：
&lt;/h4>&lt;ul>
&lt;li>&lt;strong>&lt;code>-1&lt;/code>&lt;/strong>：表示该位置为空，未被占用。&lt;/li>
&lt;li>&lt;strong>&lt;code>-2&lt;/code>&lt;/strong>：表示该位置已被锁定，当前线程正在使用该位置（通常用于进行原子操作）。&lt;/li>
&lt;li>&lt;strong>&lt;code>0&lt;/code> 到 &lt;code>numParticles - 1&lt;/code>&lt;/strong>：表示 &lt;strong>粒子&lt;/strong>，每个位置对应一个粒子。&lt;/li>
&lt;li>&lt;strong>&lt;code>numParticles&lt;/code> 或更大&lt;/strong>：表示 &lt;strong>根节点&lt;/strong>，用于标识树结构中的根节点。&lt;/li>
&lt;/ul>
&lt;h4 id="锁定位置的特殊说明">锁定位置的特殊说明：
&lt;/h4>&lt;p>根据 Burtscher 和 Pingali 的研究，树结构中的位置锁定采用如下方式：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;code>-1&lt;/code>&lt;/strong> 代表该位置为空。&lt;/li>
&lt;li>&lt;strong>&lt;code>-2&lt;/code>&lt;/strong> 代表该位置被锁定。&lt;/li>
&lt;/ul>
&lt;p>如果第 &lt;code>i&lt;/code> 个位置被锁定，那么：&lt;/p>
&lt;ul>
&lt;li>在 &lt;strong>三维&lt;/strong> 情况下，&lt;code>8*i+0&lt;/code> 到 &lt;code>7&lt;/code>（即一个八岔树及其子树等）都被锁定；&lt;/li>
&lt;li>在 &lt;strong>二维&lt;/strong> 情况下，&lt;code>4*i+0&lt;/code> 到 &lt;code>3&lt;/code>（即一个四岔树及其子树等）都被锁定；&lt;/li>
&lt;li>在 &lt;strong>一维&lt;/strong> 情况下，&lt;code>i&lt;/code> 及其相邻部分也会被锁定。&lt;/li>
&lt;/ul>
&lt;!-- 这意味着，如果一个位置被锁定，**其他线程将无法访问该位置的子树或其子树的子树**，确保了并行计算中节点及其相关子节点的安全。
### 使用原子操作同步线程
当多个线程并发地尝试访问同一个子节点槽位时，可以使用 CUDA 提供的原子操作 `atomicCAS`（Compare And Swap）来进行线程间同步。
以下是原子操作的代码示例：
```cuda
int re = atomicCAS(&amp;child[p], -1, -2); // 尝试占用 child[p]
```
该操作的含义是：
- **若 `child[p] == -1`**：表示该槽位尚未被占用，当前线程成功将其原子地设置为 `-2`，表示“锁定中”或“准备插入”；
- **若 `child[p] != -1`**：说明该槽位已被其他线程占用或已被插入，当前线程需退出或重试；
- **返回值 `re`**：表示操作前的旧值。如果 `re == -1`，则说明当前线程成功锁定了该节点。如果 `re != -1` ，则 `atomicCAS` 函数发现比较不成立，直接返回了旧值，也不会替换`-2`而打乱`child`数组内容。
写到这里，树结构数组`child`的构建就很容易了。下面是代码
```CUDA
__global__ void buildTree()
{
register int inc = blockDim.x * gridDim.x;
register int i = threadIdx.x + blockIdx.x * blockDim.x;
register int k;
register int childIndex, child;
register int lockedIndex;
register double x;
#if DIM > 1
register double y;
#endif
register double r;
register double dx;
#if DIM > 1
register double dy;
#endif
register double rootRadius = radius;
register double rootX = p.x[numNodes-1];
#if DIM > 1
register double rootY = p.y[numNodes-1];
#endif
register int depth = 0;
register int isNewParticle = TRUE;
register int currentNodeIndex;
register int newNodeIndex;
register int subtreeNodeIndex;
#if DIM == 3
register double z;
register double dz;
register double rootZ = p.z[numNodes-1];
#endif
volatile double *px, *pm;
#if DIM > 1
volatile double *py;
#if DIM == 3
volatile double *pz;
#endif
#endif
px = p.x;
pm = p.m;
#if DIM > 1
py = p.y;
#if DIM == 3
pz = p.z;
#endif
#endif
while (i &lt; numParticles) {
depth = 0;
if (isNewParticle) {
isNewParticle = FALSE;
// cache particle data
x = px[i];
p.ax[i] = 0.0;
#if DIM > 1
y = py[i];
p.ay[i] = 0.0;
#if DIM == 3
z = pz[i];
p.az[i] = 0.0;
#endif
#endif
// start at root
currentNodeIndex = numNodes-1;
r = rootRadius;
childIndex = 0;
if (x > rootX) childIndex = 1;
#if DIM > 1
if (y > rootY) childIndex += 2;
#if DIM == 3
if (z > rootZ) childIndex += 4;
#endif
#endif
}
// follow path to leaf
child = childList[childListIndex(currentNodeIndex, childIndex)];
/* leaves are 0 ... numParticles */
while (child >= numParticles) {
currentNodeIndex = child;
depth++;
r *= 0.5;
// which child?
childIndex = 0;
if (x > px[currentNodeIndex]) childIndex = 1;
#if DIM > 1
if (y > py[currentNodeIndex]) childIndex += 2;
#if DIM > 2
if (z > pz[currentNodeIndex]) childIndex += 4;
#endif
#endif
child = childList[childListIndex(currentNodeIndex, childIndex)];
}
// we want to insert the current particle i into currentNodeIndex's child at position childIndex
// where child is now empty, locked or a particle
// if empty -> simply insert, if particle -> create new subtree
if (child != LOCKED) {
// the position where we want to place the particle gets locked
lockedIndex = childListIndex(currentNodeIndex, childIndex);
// atomic compare and save: compare if child is still the current value of childlist at the index lockedIndex, if so, lock it
// atomicCAS returns the old value of child
if (child == atomicCAS((int *) &amp;childList[lockedIndex], child, LOCKED)) {
// if the destination is empty, insert particle
if (child == EMPTY) {
// insert the particle into this leaf
childList[lockedIndex] = i;
} else {
// there is already a particle, create new inner node
subtreeNodeIndex = -1;
do {
// get the next free nodeIndex
newNodeIndex = atomicSub((int * ) &amp;maxNodeIndex, 1) - 1;
// throw error if there aren't enough node indices available
if (newNodeIndex &lt;= numParticles) {
printf("(thread %d): error during tree creation: not enough nodes. newNodeIndex %d, maxNodeIndex %d, numParticles: %d\n", threadIdx.x, newNodeIndex, maxNodeIndex, numParticles);
assert(0);
}
// the first available free nodeIndex will be the subtree node
subtreeNodeIndex = max(subtreeNodeIndex, newNodeIndex);
dx = (childIndex &amp; 1) * r;
#if DIM > 1
dy = ((childIndex >> 1) &amp; 1) * r;
#if DIM == 3
dz = ((childIndex >> 2) &amp; 1) * r;
#endif
#endif
depth++;
r *= 0.5;
// we save the radius here, so we can use it during neighboursearch. we have to set it to EMPTY after the neighboursearch
pm[newNodeIndex] = r;
dx = px[newNodeIndex] = px[currentNodeIndex] - r + dx;
#if DIM > 1
dy = py[newNodeIndex] = py[currentNodeIndex] - r + dy;
#if DIM == 3
dz = pz[newNodeIndex] = pz[currentNodeIndex] - r + dz;
#endif
#endif
for (k = 0; k &lt; numChildren; k++) {
childList[childListIndex(newNodeIndex, k)] = EMPTY;
}
if (subtreeNodeIndex != newNodeIndex) {
// this condition is true when the two particles are so close to each other, that they are
// again put into the same node, so we have to create another new inner node.
// in this case, currentNodeIndex is the previous newNodeIndex
// and childIndex is the place where the particle i belongs to, relative to the previous newNodeIndex
childList[childListIndex(currentNodeIndex, childIndex)] = newNodeIndex;
}
childIndex = 0;
if (px[child] > dx) childIndex = 1;
#if DIM > 1
if (py[child] > dy) childIndex += 2;
#if DIM == 3
if (pz[child] > dz) childIndex += 4;
#endif
#endif
childList[childListIndex(newNodeIndex, childIndex)] = child;
// compare positions of particle i to the new node
currentNodeIndex = newNodeIndex;
childIndex = 0;
if (x > dx) childIndex = 1;
#if DIM > 1
if (y > dy) childIndex += 2;
#if DIM == 3
if (z > dz) childIndex += 4;
#endif
#endif
child = childList[childListIndex(currentNodeIndex, childIndex)];
// continue creating new nodes (with half radius each) until the other particle is not in the same spot in the tree
} while (child >= 0);
childList[childListIndex(currentNodeIndex, childIndex)] = i;
__threadfence();
//__threadfence() is used to halt the current thread until all previous writes to shared and global memory are visible
// by other threads. It does not halt nor affect the position of other threads though!
childList[lockedIndex] = subtreeNodeIndex;
}
p.depth[i] = depth;
// continue with next particle
i += inc;
isNewParticle = TRUE;
}
}
__syncthreads(); // child was locked, wait for other threads to unlock
}
}
```
// 核函数：构建八叉树（或四叉树/二叉树，取决于 DIM）用于粒子邻域搜索或自引力计算
// 输入：
// p - 粒子数据结构，包括位置 px, py, pz 和质量 pm，以及加速度 ax, ay, az
// numParticles - 粒子总数
// numNodes - 总节点数（包括粒子和内部节点）
// radius - 根节点大小
// 输出：
// childList - 树结构中每个节点的子节点数组
// maxNodeIndex - 原子递减的全局变量，用于分配新内部节点索引
__global__ void buildTree(ParticleData p, int* childList, int numParticles, int numNodes, double radius, int* maxNodeIndex)
{
int inc = blockDim.x * gridDim.x;
int i = threadIdx.x + blockIdx.x * blockDim.x;
while (i &lt; numParticles) {
double x = p.x[i], y = 0.0, z = 0.0;
#if DIM > 1
y = p.y[i];
#if DIM == 3
z = p.z[i];
#endif
#endif
double ax = 0.0, ay = 0.0, az = 0.0;
p.ax[i] = ax;
#if DIM > 1
p.ay[i] = ay;
#if DIM == 3
p.az[i] = az;
#endif
#endif
// 从根节点开始
int currentNodeIndex = numNodes - 1;
double rootX = p.x[currentNodeIndex];
double rootY = 0.0, rootZ = 0.0;
#if DIM > 1
rootY = p.y[currentNodeIndex];
#if DIM == 3
rootZ = p.z[currentNodeIndex];
#endif
#endif
double r = radius;
int depth = 0;
// 确定初始的子节点索引
int childIndex = 0;
if (x > rootX) childIndex |= 1;
#if DIM > 1
if (y > rootY) childIndex |= 2;
#if DIM == 3
if (z > rootZ) childIndex |= 4;
#endif
#endif
// 遍历树直到遇到叶子节点或空位
int child = childList[childListIndex(currentNodeIndex, childIndex)];
while (child >= numParticles) {
currentNodeIndex = child;
depth++;
r *= 0.5;
// 再次确定子节点索引
childIndex = 0;
if (x > p.x[currentNodeIndex]) childIndex |= 1;
#if DIM > 1
if (y > p.y[currentNodeIndex]) childIndex |= 2;
#if DIM == 3
if (z > p.z[currentNodeIndex]) childIndex |= 4;
#endif
#endif
child = childList[childListIndex(currentNodeIndex, childIndex)];
}
// 尝试锁定子节点槽位
int lockedIndex = childListIndex(currentNodeIndex, childIndex);
if (child != LOCKED &amp;&amp; child == atomicCAS(&amp;childList[lockedIndex], child, LOCKED)) {
if (child == EMPTY) {
childList[lockedIndex] = i;
} else {
// 创建新子树
int subtreeNodeIndex = -1;
do {
int newNodeIndex = atomicSub(maxNodeIndex, 1) - 1;
if (newNodeIndex &lt;= numParticles) {
printf("ERROR: Not enough nodes. newNodeIndex = %d\n", newNodeIndex);
return;
}
subtreeNodeIndex = max(subtreeNodeIndex, newNodeIndex);
double dx = (childIndex &amp; 1) * r;
double dy = 0.0, dz = 0.0;
#if DIM > 1
dy = ((childIndex >> 1) &amp; 1) * r;
#if DIM == 3
dz = ((childIndex >> 2) &amp; 1) * r;
#endif
#endif
r *= 0.5;
p.m[newNodeIndex] = r;
p.x[newNodeIndex] = p.x[currentNodeIndex] - r + dx;
#if DIM > 1
p.y[newNodeIndex] = p.y[currentNodeIndex] - r + dy;
#if DIM == 3
p.z[newNodeIndex] = p.z[currentNodeIndex] - r + dz;
#endif
#endif
for (int k = 0; k &lt; numChildren; ++k)
childList[childListIndex(newNodeIndex, k)] = EMPTY;
if (subtreeNodeIndex != newNodeIndex)
childList[childListIndex(currentNodeIndex, childIndex)] = newNodeIndex;
// 再次寻找当前粒子与已有粒子应处位置
childIndex = 0;
if (p.x[child] > p.x[newNodeIndex]) childIndex |= 1;
#if DIM > 1
if (p.y[child] > p.y[newNodeIndex]) childIndex |= 2;
#if DIM == 3
if (p.z[child] > p.z[newNodeIndex]) childIndex |= 4;
#endif
#endif
childList[childListIndex(newNodeIndex, childIndex)] = child;
currentNodeIndex = newNodeIndex;
childIndex = 0;
if (x > p.x[currentNodeIndex]) childIndex |= 1;
#if DIM > 1
if (y > p.y[currentNodeIndex]) childIndex |= 2;
#if DIM == 3
if (z > p.z[currentNodeIndex]) childIndex |= 4;
#endif
#endif
child = childList[childListIndex(currentNodeIndex, childIndex)];
} while (child >= 0);
childList[childListIndex(currentNodeIndex, childIndex)] = i;
__threadfence();
childList[lockedIndex] = subtreeNodeIndex;
}
p.depth[i] = depth;
i += inc;
}
__syncthreads(); // 等待锁释放
}
}
-->
&lt;p>[1] Burtscher, Martin, and Keshav Pingali. &amp;ldquo;An efficient CUDA implementation of the tree-based barnes hut n-body algorithm.&amp;rdquo; &lt;em>GPU computing Gems Emerald edition&lt;/em>. Morgan Kaufmann, 2011. 75-92.&lt;/p></description></item></channel></rss>